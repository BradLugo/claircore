// Revlookup is a small tool meant to be run via "go generate" to generate
// reverse-lookup tables for github.com/quay/claircore/toolkit/types/cvss.
package main

import (
	"bytes"
	"flag"
	"fmt"
	"go/format"
	"io"
	"os"
	"strings"

	"github.com/quay/claircore/toolkit/types/cvss"
)

func main() {
	pkg := flag.String("package", "cvss", "package name to generate")
	toMake := flag.String("version", "234", "version numbers to generate lookup table for")
	outName := flag.String("o", "-", "output file name ('-' for stdout)")
	flag.Parse()

	var w bytes.Buffer
	fmt.Fprintf(&w, preamble, *pkg)
	stripPrefix := *pkg == `cvss`
	if *pkg != `cvss` {
		fmt.Fprintln(&w, `import "github.com/quay/claircore/toolkit/types/cvss"`)
	}
	if strings.Contains(*toMake, "4") {
		if err := mkRevLookup[cvss.V4Metric](&w, stripPrefix); err != nil {
			panic(err)
		}
	}
	if strings.Contains(*toMake, "3") {
		if err := mkRevLookup[cvss.V3Metric](&w, stripPrefix); err != nil {
			panic(err)
		}
	}
	if strings.Contains(*toMake, "2") {
		if err := mkRevLookup[cvss.V2Metric](&w, stripPrefix); err != nil {
			panic(err)
		}
	}

	b, err := format.Source(w.Bytes())
	if err != nil {
		fmt.Println(w.String())
		panic(err)
	}

	var out *os.File
	if *outName == "-" {
		out = os.Stdout
	} else {
		out, err = os.Create(*outName)
		if err != nil {
			panic(err)
		}
		defer out.Close()
	}
	if _, err := io.Copy(out, bytes.NewReader(b)); err != nil {
		panic(err)
	}
}

const preamble = `// Code generated by internal/cmd/revlookup. DO NOT EDIT.

package %s

`

// MkRevLookup constructs a reverse-lookup table for the [Metric] M.
//
// This is used to go "backwards" from the [fmt.Stringer] representation.
func mkRevLookup[M cvss.Metric](w *bytes.Buffer, stripPrefix bool) error {
	var m M
	var prefix string
	switch any(&m).(type) {
	case *cvss.V4Metric:
		prefix = "v4"
	case *cvss.V3Metric:
		prefix = "v3"
	case *cvss.V2Metric:
		prefix = "v2"
	default:
		panic(fmt.Sprintf("programmer error: unknown type: %T", &m))
	}
	var pre string
	if stripPrefix {
		pre = "cvss."
	}
	kind := strings.TrimPrefix(fmt.Sprintf("%T", m), pre)
	fmt.Fprintf(w, "var %sRev = map[string]%s{\n", prefix, kind)
	for i := 0; ; i++ {
		m := M(i)
		v := m.String()
		if strings.Contains(v, "Metric(") {
			break
		}
		fmt.Fprintf(w, "%q: %d,\n", v, i)
	}
	fmt.Fprintf(w, "}\n\n")
	return nil
}
